# The Longest Line of Origanisms

## Problem Statement

Among certain species, a single-celled organism stores their genetic information in one line of DNA. For reference, DNA is a string of four characters: A, C, T, G in a repeated way. Assume that we have DNA of N number of organisms of the species in the sequence when they are born.

The organism gives birth only once in their lifetime, and their child is simply separated from their parent’s organism. The child’s DNA is different from that of parent, __and they are generated by adding more than one character to back of their parent’s DNA.__

When we look at DNA of N number of organisms in the order of birth, if the DNA of a later-born organism has the full DNA of a earlier-born organism as prefix, they have the possibility of being a parent-child relationship.

We try to choose a part of DNA of organisms given as input to meet following condition: __When we arrange them in the sequence when they are born__, all neighboring pairs should have the possibility of being a parent-child relationship. Also, we want to make the number of choosed DNA the largest, as long as the condition are met.

### example

```bash
A
A
AT
AG
AGG
```

Should have the one of the longest A(can be ether) - AG - AGG.

## Solution

### Trie

Due to the natural of the input, trie is quite obvious.

### The order of birth matters

Let's say AT, A, ATG, this input only result in 2 longest possible chain.

### Code

```java
public void compute(List<String> genes) {
  Node root = new Node();
  int max = 0;

  for (String gene : genes) {
    int count = insert(root, gene);
    max = Math.max(count, max);
  }
}

private int insert(Node root, String gene) {
  Node curr = root;
  int count = 0;

  for (int i = 0; i < gene.length(); i++) {
    if (curr.isGene) count = Math.max(curr.count, count);
    int j = idx(gene.charAt(i));
    if (curr.children[j] == null) curr.children[j] = new Node();
    curr = curr.children[j];
  }
  curr.isGene = true;
  curr.count = count + 1;
    System.out.println(gene + "," + (count + 1));
  return curr.count;
}

private int idx(char c) {
  switch (c) {
    case 'A':
      return 0;
    case 'C':
      return 1;
    case 'T':
      return 2;
    case 'G':
      return 3;
    default:
      return -1;
  }
}

class Node {
  Node[] children = new Node[4];
  int count;
  boolean isGene;
}
```
