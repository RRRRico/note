# Polish Notation

Normal math expressions are written in **Infix Notation** e.g.  $3 - 6 \* 3$ which can be represent in a form of binary tree:

```bash
         -
        / \
     3     *
             /    \
          6     3
```

However, **Postfix Notation** is easier for computer to perform the calculation. E.g. $3, 6, 3, _, -$ which is exactly the sequence generated by \*Postorder Tree Walk_ of binary tree.

## Basic Calculator

Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus sign `-`, **non-negative** integers and empty spaces \`\`.

The expression string contains only non-negative integers, `+`, `-`, `*`, `/` operators , open `(` and closing parentheses `)` and empty spaces \`\`. The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of `[-2147483648, 2147483647]`.

Some examples:

```text
"1 + 1" = 2
" 6-4 / 2 " = 4
"2*(5+5*2)/3+(6/2+8)" = 21
"(2+6* 3+5- (3*14/7+2)*5)+3"=-12
```

### Solution

```java
class Solution {
  public int calculate(String s) {
    Deque<Integer> nums = new LinkedList<>();
    Deque<Character> op = new LinkedList<>();

    int val = 0;
    boolean valid = false; // indicate if a number exists
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if (c == ' ') continue;
      if (isDigit(c)) {
        val = val * 10 + (c - '0');
        valid = true;
      }
      else {
        if (valid) {
          nums.push(val);
          valid = false;
          val = 0;
        }
        // push open bracket into stack
        if (c == '(') op.push(c);
        else if (c == ')') {
          // since higher rank operations are already calculated,
          // we can confidently accumulate value
          while (op.peek() != '(') accumulate(nums, op);
          op.pop();
        } else {
          // higher rank operations perform first
          while (!op.isEmpty() && rank(c) <= rank(op.peek())) accumulate(nums, op);
          op.push(c);
        }
      }
    }
    // if there's remaining number
    if(valid) nums.push(val);

    while (!op.isEmpty()) accumulate(nums, op);
    return nums.pop();
  }

  private void accumulate(Deque<Integer> nums, Deque<Character> op) {
    nums.push(calc(nums.pop(), nums.pop(), op.pop()));
  }

  private int rank(char c) {
    if (c == '(') return 0;
    if (c == '-' || c == '+') return 1;
    if (c == '*' || c == '/') return 2;
    return 3;
  }

  private boolean isDigit(char c) {
    return c >= '0' && c <= '9';
  }

  private int calc(int a, int b, char op) {
    switch (op) {
      // reverse a and b for easy stack operation
      case '+' : return b + a;
      case '-' : return b - a;
      case '*' : return b * a;
      case '/' : return b / a;
      default : return 0;
    }
  }
}
```

